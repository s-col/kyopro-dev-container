{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Kyopro": {
		"prefix": "kyopro",
		"body": [
			"#include <bits/stdc++.h>",
			"#define FASTIO",
			"using namespace std;",
			"",
			"using ll = long long;",
			"using Vi = std::vector<int>;",
			"using Vl = std::vector<ll>;",
			"using Pii = std::pair<int, int>;",
			"using Pll = std::pair<ll, ll>;",
			"template <class T>",
			"using min_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;",
			"",
			"constexpr int I_INF = std::numeric_limits<int>::max();",
			"constexpr ll L_INF = std::numeric_limits<ll>::max();",
			"",
			"template <typename T1, typename T2>",
			"inline bool chmin(T1& a, const T2& b) {",
			"    if (a > b) {",
			"        a = b;",
			"        return true;",
			"    }",
			"    return false;",
			"}",
			"template <typename T1, typename T2>",
			"inline bool chmax(T1& a, const T2& b) {",
			"    if (a < b) {",
			"        a = b;",
			"        return true;",
			"    }",
			"    return false;",
			"}",
			"",
			"template <std::ostream& os = std::cout>",
			"class Prints {",
			"private:",
			"    class __Prints {",
			"    public:",
			"        __Prints(const char* sep, const char* term) : sep(sep), term(term) {}",
			"        template <class... Args>",
			"#if __cplusplus >= 201703L",
			"        auto operator()(const Args&... args) const -> decltype((os << ... << std::declval<Args>()), void()) {",
			"#else",
			"        void operator()(const Args&... args) const {",
			"#endif",
			"            print(args...);",
			"        }",
			"        template <typename T>",
			"#if __cplusplus >= 201703L",
			"        auto pvec(const T& vec, size_t sz) const -> decltype(os << std::declval<decltype(std::declval<T>()[0])>(), void()) {",
			"#else",
			"        void pvec(const T& vec, size_t sz) const {",
			"#endif",
			"            for (size_t i = 0; i < sz; i++)",
			"                os << vec[i] << (i == sz - 1 ? term : sep);",
			"        }",
			"        template <typename T>",
			"#if __cplusplus >= 201703L",
			"        auto pmat(const T& mat, size_t h, size_t w) const -> decltype(os << std::declval<decltype(std::declval<T>()[0][0])>(), void()) {",
			"#else",
			"        void pmat(const T& mat, size_t h, size_t w) const {",
			"#endif",
			"            for (size_t i = 0; i < h; i++)",
			"                for (size_t j = 0; j < w; j++)",
			"                    os << mat[i][j] << (j == w - 1 ? term : sep);",
			"        }",
			"",
			"    private:",
			"        const char *sep, *term;",
			"        void print() const { os << term; }",
			"        void print_rest() const { os << term; }",
			"        template <class T, class... Tail>",
			"        void print(const T& head, const Tail&... tail) const { os << head, print_rest(tail...); }",
			"        template <class T, class... Tail>",
			"        void print_rest(const T& head, const Tail&... tail) const { os << sep << head, print_rest(tail...); }",
			"    };",
			"",
			"public:",
			"    Prints() {}",
			"    __Prints operator()(const char* sep = \" \", const char* term = \"\\n\") const { return __Prints(sep, term); }",
			"};",
			"",
			"Prints<> prints;",
			"Prints<std::cerr> prints_err;",
			"",
			"//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
			"",
			"$0",
			"",
			"//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
			"",
			"int main() {",
			"#ifdef FASTIO",
			"    std::cin.tie(nullptr), std::cout.tie(nullptr);",
			"    std::ios::sync_with_stdio(false);",
			"#endif",
			"#ifdef FILEINPUT",
			"    std::ifstream ifs(\"./in_out/input.txt\");",
			"    std::cin.rdbuf(ifs.rdbuf());",
			"#endif",
			"#ifdef FILEOUTPUT",
			"    std::ofstream ofs(\"./in_out/output.txt\");",
			"    std::cout.rdbuf(ofs.rdbuf());",
			"#endif",
			"    std::cout << std::setprecision(18) << std::fixed;",
			"    solve();",
			"    std::cout << std::flush;",
			"    return 0;",
			"}",
		],
		"description": "初期テンプレート"
	},
	"single": {
		"prefix": "single",
		"body": [
			"void solve() {",
			"    $0",
			"}"
		]
	},
	"multi": {
		"prefix": "multi",
		"body": [
			"inline void solve_one() {",
			"    $0",
			"}",
			"",
			"void solve() {",
			"    int Q;",
			"    cin >> Q;",
			"    while(Q--) solve_one();",
			"}"
		]
	},
	// for
	"Ifor": {
		"prefix": "ifor",
		"body": [
			"for (${1:ll} ${2:i} = ${3:0}; $2 < ${4:N}; $2++) {",
			"    $0",
			"}"
		],
		"description": "for"
	},
	"Efor": {
		"prefix": "eifor",
		"body": [
			"for (${1:ll} ${2:i} = ${3:0}; $2 <= ${4:N}; $2++) {",
			"    $0",
			"}"
		],
		"description": "for"
	},
	"Iifor": {
		"prefix": "iifor",
		"body": [
			"for (${1:ll} ${2:i} = ${3:N} - 1; $2 >= ${4:0}; $2--) {",
			"    $0",
			"}"
		],
		"description": "reverse for"
	},
	// util
	"BeginEnd": {
		"prefix": "be",
		"body": "${1}.begin(), ${1}.end()"
	},
	"FillAll": {
		"prefix": "fillall",
		"body": "fill_n((${1:int}*)${2:dp}, sizeof($2) / sizeof($1), $3);"
	},
	// yes/no
	"YesNo": {
		"prefix": "Yes",
		"body": "prints()(${1:ok} ? \"Yes\" : \"No\");"
	},
	"YESNO": {
		"prefix": "YES",
		"body": "prints()(${1:ok} ? \"YES\" : \"NO\");"
	},
	"yesno": {
		"prefix": "yes",
		"body": "prints()(${1:ok} ? \"yes\" : \"no\");"
	},
	// z-combinator
	"fix": {
		"prefix": "fix",
		"body": [
			"template <typename F>",
			"inline constexpr decltype(auto) fix(F&& f) noexcept {",
			"    return [=](auto g) {",
			"        return [=](auto&&... args) {",
			"            return f(g(g), std::forward<decltype(args)>(args)...);",
			"        };",
			"    }([=](auto g) {",
			"        return [=](auto&&... args) {",
			"            return f(g(g), std::forward<decltype(args)>(args)...);",
			"        };",
			"    });",
			"}"
		]
	},
	// Graph
	"Using_Graph": {
		"prefix": "using Graph",
		"body": "using Graph = std::vector<std::vector<int>>;"
	},
	"Using_WeightedGraph": {
		"prefix": "using WeightedGraph",
		"body": [
			"template <typename T>",
			"struct WeightedEdge {",
			"    int to;",
			"    T cost;",
			"    constexpr WeightedEdge(int to, T cost = -1) noexcept : to(to), cost(cost) {}",
			"};",
			"template <typename T>",
			"using WeightedGraph = std::vector<std::vector<WeightedEdge<T>>>;",
		]
	},
	// グリッド関係
	"Step4": {
		"prefix": "step4",
		"body": "constexpr Pii step[4] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};"
	},
	"Step8": {
		"prefix": "step8",
		"body": "constexpr Pii step[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};"
	},
	// 線形篩
	"Sieve": {
		"prefix": "sieve",
		"body": [
			"constexpr int LIM = 100000;",
			"std::vector<int> mpf(LIM + 1);",
			"std::vector<int> primes;",
			"for (int i = 2; i <= LIM; i++) {",
			"    if (mpf[i] == 0) {",
			"        mpf[i] = i;",
			"        primes.emplace_back(i);",
			"    }",
			"    for (const auto& p : primes) {",
			"        if (i * p > LIM || p > mpf[i]) break;",
			"        mpf[i * p] = p;",
			"    }",
			"}",
		],
	},
}